<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - shader - curvature [heart]</title>
		<div class="label" style="position: absolute;left: 22%;bottom: 10%;">Raw curvature values</div>
		<div class="label" style="position: absolute;left: 71%;bottom: 10%;">Curvature driving specular + texture </div>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #ffffff;
			}

			#oldie a { color:#da0 }
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - curvature estimation of a geometry by <a href="http://codercat.club" target="_blank" rel="noopener">CoderCat</a></div>

		<script src="../build/three.js"></script>
		<script src="js/Detector.js"></script>

		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">

		attribute float curvature;

		varying vec3 vPos;
		varying vec3 vNormal;
		varying vec3 vViewPosition;
		varying float vCurvature;
		varying vec2 vUv;

		uniform sampler2D tex;

		void main() {

			vec3 p = position;
			vPos = p;
			vec4 modelViewPosition = modelViewMatrix * vec4( p , 1.0 );
			vViewPosition = -modelViewPosition.xyz;
			gl_Position = projectionMatrix * modelViewPosition;
			vNormal = normalMatrix * normal;
			vCurvature = curvature;
			vUv = uv;

		}

		</script>

		<script id="fragmentShaderRaw" type="x-shader/x-fragment">

		varying vec3 vNormal;
		varying vec3 vViewPosition;
		varying float vCurvature;

		void main() {
				gl_FragColor = vec4( vCurvature * 2.0, 0.0, 0.0, 0.0 );
		}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

		varying vec3 vPos;
		varying vec3 vNormal;
		varying vec3 vViewPosition;
		varying float vCurvature;
		varying vec2 vUv;

		vec4 permute( vec4 x ){ return mod((( x * 34.0 ) + 1.0 ) * x, 289.0); }
		vec4 taylorInvSqrt( vec4 r ){ return 1.79284291400159 - 0.85373472095314 * r; }
		vec3 fade( vec3 t ) { return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 ); }

		float cnoise( vec3 P ){
		  vec3 Pi0 = floor( P ); // Integer part for indexing
		  vec3 Pi1 = Pi0 + vec3( 1.0 ); // Integer part + 1
		  Pi0 = mod( Pi0, 289.0 );
		  Pi1 = mod( Pi1, 289.0 );
		  vec3 Pf0 = fract( P ); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3( 1.0 ); // Fractional part - 1.0
		  vec4 ix = vec4( Pi0.x, Pi1.x, Pi0.x, Pi1.x );
		  vec4 iy = vec4( Pi0.yy, Pi1.yy );
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute( permute( ix ) + iy );
		  vec4 ixy0 = permute( ixy + iz0 );
		  vec4 ixy1 = permute( ixy + iz1 );

		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract( floor( gx0 ) / 7.0 ) - 0.5;
		  gx0 = fract( gx0 );
		  vec4 gz0 = vec4( 0.5 ) - abs( gx0 ) - abs( gy0 );
		  vec4 sz0 = step( gz0, vec4( 0.0 ));
		  gx0 -= sz0 * ( step( 0.0, gx0 ) - 0.5 );
		  gy0 -= sz0 * ( step( 0.0, gy0 ) - 0.5 );

		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract( floor( gx1 ) / 7.0 ) - 0.5;
		  gx1 = fract( gx1 );
		  vec4 gz1 = vec4( 0.5 ) - abs( gx1 ) - abs( gy1 );
		  vec4 sz1 = step( gz1, vec4( 0.0 ) );
		  gx1 -= sz1 * ( step( 0.0, gx1 ) - 0.5 );
		  gy1 -= sz1 * ( step( 0.0, gy1 ) - 0.5 );

		  vec3 g000 = vec3( gx0.x, gy0.x, gz0.x );
		  vec3 g100 = vec3( gx0.y, gy0.y, gz0.y );
		  vec3 g010 = vec3( gx0.z, gy0.z, gz0.z );
		  vec3 g110 = vec3( gx0.w, gy0.w, gz0.w );
		  vec3 g001 = vec3( gx1.x, gy1.x, gz1.x );
		  vec3 g101 = vec3( gx1.y, gy1.y, gz1.y );
		  vec3 g011 = vec3( gx1.z, gy1.z, gz1.z );
		  vec3 g111 = vec3( gx1.w, gy1.w, gz1.w );

		  vec4 norm0 = taylorInvSqrt( vec4( dot( g000, g000 ), dot( g010, g010 ), dot( g100, g100 ), dot( g110, g110 ) ) );
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt( vec4( dot( g001, g001 ), dot( g011, g011 ), dot( g101, g101 ), dot( g111, g111 ) ) );
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot( g000, Pf0 );
		  float n100 = dot( g100, vec3( Pf1.x, Pf0.yz ) );
		  float n010 = dot( g010, vec3( Pf0.x, Pf1.y, Pf0.z ) );
		  float n110 = dot( g110, vec3( Pf1.xy, Pf0.z ) );
		  float n001 = dot( g001, vec3( Pf0.xy, Pf1.z ) );
		  float n101 = dot( g101, vec3( Pf1.x, Pf0.y, Pf1.z ) );
		  float n011 = dot( g011, vec3( Pf0.x, Pf1.yz ) );
		  float n111 = dot( g111, Pf1);

		  vec3 fade_xyz = fade( Pf0 );
		  vec4 n_z = mix( vec4( n000, n100, n010, n110 ), vec4( n001, n101, n011, n111 ), fade_xyz.z );
		  vec2 n_yz = mix( n_z.xy, n_z.zw, fade_xyz.y );
		  float n_xyz = mix( n_yz.x, n_yz.y, fade_xyz.x );
		  return 2.2 * n_xyz;

		}

		void main() {
			vec3 V = vViewPosition; //view vector
			vec3 N = vNormal; //normal vector
			vec3 L = vec3( 55.0, 55.0, 15.0 ); //imaginary light
			vec3 R = reflect( -L, N ); //reflection from light

			//specular coefficient
			float spec = vCurvature * vCurvature * max( 0.0, dot( R, normalize( V ) ) / 5.0 );
			vec4 specColor = vec4( 1.0, 1.0, 1.0, 1.0 );

			//calculate noise coefficient
			float x = cnoise( 10.0 * vPos );
			vec4 diffuseColor = vec4(x, x, x, 1.0 );
			diffuseColor.xyz = pow( vCurvature , 2.0 ) * diffuseColor.xyz;

			gl_FragColor = spec * specColor + diffuseColor;

		}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;

			var camera, scene, sceneLeft, renderer;

			var heartMesh, curvatureAttribute;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			//returns average of elements in a dictionary
			function average( dict ) {

				var sum = 0;
				var length = 0;

				Object.keys( dict ).forEach( function( key ) {

					sum += dict[ key ];
					length ++;

				});

				return sum / length;

			}

			//clamp a number between min and max
			function clamp( number, min, max ) {

			  return Math.max( min, Math.min( number, max ) );

			}

			//filter the curvature array to only show concave values
			function filterConcave( curvature ) {

				for ( var i = 0; i < curvature.length; i++ ) {

					curvature[ i ] = Math.abs( clamp( curvature[ i ], -1, 0 ) );

				}

			}

			//filter the curvature array to only show convex values
			function filterConvex( curvature ) {

				for ( var i = 0; i < curvature.length; i++ ) {

					curvature[ i ] = clamp( curvature[ i ], 0, 1 );

				}

			}

			//filter the curvature array to show both the concave and convex values
			function filterBoth( curvature ) {

				for ( var i = 0; i < curvature.length; i++ ) {

					curvature[ i ] = Math.abs( curvature[ i ] );

				}

			}

			//initialize the scene
			function init() {

				sceneRight = new THREE.Scene();
				sceneLeft = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 75, windowHalfX / window.innerHeight, 0.1, 1000 );
				camera.position.z = 9;
				camera.position.x = 14;
				camera.position.y =  4;

				controls = new THREE.OrbitControls( camera );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;

				document.body.appendChild( renderer.domElement );

				var loader = new THREE.OBJLoader();
				//load the obj
				loader.load( 'obj/heart/heart.obj', function ( object ) {
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {

							bufferGeo = child.geometry;
							var dict= {};

							for ( var i = 0; i < bufferGeo.attributes.position.count; i+=3 ) {
								//create a dictionary of every position, and its neighboring positions
								var array = bufferGeo.attributes.position.array;
								var normArray = bufferGeo.attributes.normal.array;

								var posA = new THREE.Vector3(array[ 3 * i ], array[ 3 * i + 1 ], array[ 3 * i + 2 ]);
								var posB = new THREE.Vector3(array[ 3 * ( i + 1 ) ], array[ 3 * ( i + 1 ) + 1 ], array[ 3 * ( i + 1 ) + 2 ]);
								var posC = new THREE.Vector3(array[ 3 * ( i + 2 ) ], array[ 3 * ( i + 2 ) + 1 ], array[ 3 * ( i + 2 ) + 2 ]);

								var normA = new THREE.Vector3(normArray[ 3 * i ], normArray[ 3 * i + 1 ], normArray[ 3 * i + 2 ]).normalize();
								var normB = new THREE.Vector3(normArray[ 3 * ( i + 1 ) ], normArray[ 3 * ( i + 1 ) + 1 ], normArray[ 3 * ( i + 1 ) + 2 ]).normalize();
								var normC = new THREE.Vector3(normArray[ 3 * ( i + 2 ) ], normArray[ 3 * ( i + 2 ) + 1 ], normArray[ 3 * ( i + 2 ) + 2 ]).normalize();

								var strA = posA.toArray().toString();
								var strB = posB.toArray().toString();
								var strC = posC.toArray().toString();

								var posB_A = new THREE.Vector3().subVectors( posB, posA );
								var posB_C = new THREE.Vector3().subVectors( posB, posC );
								var posC_A = new THREE.Vector3().subVectors( posC, posA );

								var normB_A = new THREE.Vector3().subVectors( normB, normA );
								var normB_C = new THREE.Vector3().subVectors( normB, normC );
								var normC_A = new THREE.Vector3().subVectors( normC, normA );

								var b2a = normB.dot( posB_A.normalize()  );
								var b2c = normB.dot( posB_C.normalize()  );
								var c2a = normC.dot( posC_A.normalize()  );

								var a2b = -normA.dot( posB_A.normalize()  );
								var c2b = -normC.dot( posB_C.normalize()  );
								var a2c = -normA.dot( posC_A.normalize()  );

								if (dict[ strA ] === undefined ) {
									dict[ strA ] = {};
								}
								if (dict[ strB ] === undefined ) {
									dict[ strB ] = {};
								}
								if (dict[ strC ] === undefined ) {
									dict[ strC ] = {};
								}

								dict[ strA ][ strB ] = a2b;
								dict[ strA ][ strC ] = a2c;
								dict[ strB ][ strA ] = b2a;
								dict[ strB ][ strC ] = b2c;
								dict[ strC ][ strA ] = c2a;
								dict[ strC ][ strB ] = c2b;

							}

							curvatureDict = {};
							var min = 10, max = 0;

							Object.keys( dict ).forEach( function( key ) {

    						curvatureDict[ key ] = average( dict[ key ] );

							});

							//smoothing
							var smoothCurvatureDict  = Object.create(curvatureDict);

							Object.keys( dict ).forEach( function( key ) {

								var count = 0;
								var sum = 0;
								Object.keys( dict[ key ] ).forEach( function( key2 ) {

									sum += smoothCurvatureDict[ key2 ];
									count ++;

								});
								smoothCurvatureDict[key] = sum / count;

							});

							curvatureDict = smoothCurvatureDict;

							// fit values to 0 and 1
							Object.keys( curvatureDict ).forEach( function( key ) {

								val = Math.abs( curvatureDict[ key ] );
								if ( val < min ) min = val;
								if ( val > max ) max = val;

							});

							var range = ( max - min );

							Object.keys( curvatureDict ).forEach( function( key ) {

								val = Math.abs( curvatureDict[ key ] );
								if ( curvatureDict[ key ] < 0 ) {
									curvatureDict[ key ] = (min - val) / range
								} else {
									curvatureDict[ key ] = (val - min) / range;
								}

							});

							curvatureAttribute = new Float32Array( bufferGeo.attributes.position.count );

							for ( var i = 0; i < bufferGeo.attributes.position.count; i++ ) {

								array = bufferGeo.attributes.position.array;
								var pos = new THREE.Vector3( array[ 3 * i ], array[ 3 * i + 1 ], array[ 3 * i + 2 ] );
								var str = pos.toArray().toString();
								curvatureAttribute[i] = curvatureDict[ str ];

							}

							bufferGeo.addAttribute( 'curvature', new THREE.BufferAttribute( curvatureAttribute, 1 ) );

							//starting filter is to show both concave and convex
							var curvatureFiltered = new Float32Array( curvatureAttribute );
							filterBoth(curvatureFiltered);
							bufferGeo.attributes.curvature.array = curvatureFiltered;


							var material = new THREE.ShaderMaterial ({

								vertexShader: document.getElementById( 'vertexShader' ).textContent,
								fragmentShader: document.getElementById( 'fragmentShader' ).textContent

							} );

							heartMesh = new THREE.Mesh( bufferGeo, material );

							var materialRaw = new THREE.ShaderMaterial ({

								vertexShader: document.getElementById( 'vertexShader' ).textContent,
								fragmentShader: document.getElementById( 'fragmentShaderRaw' ).textContent

							} );

							heartMeshRaw = new THREE.Mesh( bufferGeo, materialRaw );

						}
					} );
					sceneRight.add( heartMesh );
					sceneLeft.add( heartMeshRaw );

				} );


				//init GUI
				var params = {
					filterConvex: function () {

						var curvatureFiltered = new Float32Array( curvatureAttribute );
						filterConvex(curvatureFiltered);
						heartMesh.geometry.attributes.curvature.array = curvatureFiltered;

					},
					filterConcave: function () {

						var curvatureFiltered = new Float32Array( curvatureAttribute );
						filterConcave(curvatureFiltered);
						heartMesh.geometry.attributes.curvature.array = curvatureFiltered;

					},
					filterBoth: function () {

						var curvatureFiltered = new Float32Array( curvatureAttribute );
						filterBoth(curvatureFiltered);
						heartMesh.geometry.attributes.curvature.array = curvatureFiltered;

					}
				};

				var gui = new dat.GUI();

				topologyFolder = gui.addFolder( 'Topology' );
				topologyFolder.add( params, 'filterConvex' );
				topologyFolder.add( params, 'filterConcave' );
				topologyFolder.add( params, 'filterBoth' );
				topologyFolder.open()

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize( event ) {

				renderer.setSize( window.innerWidth, window.innerHeight );
				windowHalfX = window.innerWidth / 2;
				camera.aspect = windowHalfX / window.innerHeight;
				camera.updateProjectionMatrix();

			}

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				controls.update();
				heartMesh.geometry.attributes.curvature.needsUpdate = true;

				renderer.clear();
				renderer.setViewport( windowHalfX, 0, windowHalfX, window.innerHeight );
				renderer.render(sceneRight, camera);

				renderer.clearDepth();
				renderer.setViewport( 0, 0, windowHalfX, window.innerHeight );
				renderer.render(sceneLeft, camera);

			}

		</script>

	</body>
</html>
