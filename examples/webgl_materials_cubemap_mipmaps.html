<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - cubemap mipmaps</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - cubemap customized mipmaps demo. Author <a href="https://github.com/AngusLang">Angus</a><br/>
			Top: webgl generated mipmaps<br/>
			Bottom: customized mimaps
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			var container, stats;

			var camera, scene, renderer, backgound;

			init();
			animate();

			// load custmized cube texture
			async function loadCubeTexture( path, imageWidth ) {

				//fetch data
				var response = await fetch( path );
				var arrayBuffer = await response.arrayBuffer();

				var cubeTextures = [];
				var byteOffset = 0;
				const maxLevel = Math.log( imageWidth ) / Math.LN2;

				for ( var level = 0; level <= maxLevel; ++ level ) {

					var size = Math.pow( 2, maxLevel - level );
					var imageByteLength = size * size * 4;
					var textures = [];
					
					if ( byteOffset >= arrayBuffer.byteLength ) {

						break;

					}

					for ( var face = 0; face < 6; ++ face ) {

						var imageData = new Uint8Array( arrayBuffer, byteOffset, imageByteLength );
						var texture = new THREE.DataTexture( imageData, size, size, THREE.RGBAFormat, THREE.UnsignedByteType );
						textures.push( texture );
						byteOffset += imageByteLength;
					}

					var levelCubeTexture = new THREE.CubeTexture( textures );
					cubeTextures.push( levelCubeTexture );
				}

				var customizedCubeTexture = cubeTextures[0];
				customizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;
				customizedCubeTexture.magFilter = THREE.LinearFilter;
				customizedCubeTexture.format = THREE.RGBAFormat;
				customizedCubeTexture.encoding = THREE.LogLuvEncoding;

				if ( cubeTextures.length > 0 ) {

					customizedCubeTexture.mipmaps = cubeTextures;
					customizedCubeTexture.generateMipmaps = false;

				}

				customizedCubeTexture.needsUpdate = true;

				return customizedCubeTexture;

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1500;

				//load cubemap

				scene = new THREE.Scene();

				//lights
				var ambient = new THREE.AmbientLight( 0xffffff, 1.0 );
				scene.add( ambient );

				var pendings = [];
				loadCubeTexture( 'textures/cube/angus/specular_cubemap_256_luv.bin', 256 ).then( function ( reflectCubeTexture ) {

					//rewrite mipmaps
					var originalCubeTexture = reflectCubeTexture.clone();
					originalCubeTexture.generateMipmaps = true;
					originalCubeTexture.needsUpdate = true;

					//models
					var sphere = new THREE.SphereBufferGeometry( 100, 128, 128 );

					var material = new THREE.MeshPhongMaterial( { color: 0xffffff, envMap: reflectCubeTexture } );

					var offset = 250;
					var originX = -1150;
					for ( var i = 0; i < 10; ++ i ) {

						//customize mipmaps sphere
						var roughness = 0.6 * i / 10 + 0.4;
						var cm = material.clone();
						cm.envMap = originalCubeTexture;

						var c = new THREE.Mesh( sphere, cm );
						c.position.set( originX + i * offset, 150, 0 );
						scene.add( c );

						//webgl mipmaps sphere
						var om = material.clone();

						var o = new THREE.Mesh( sphere, om );
						o.position.set( originX + i * offset, -150, 0 );
						scene.add( o );
					}

				} );

				//renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setClearColor( 0xf1f3f5 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//controls
				var controls = new OrbitControls( camera, renderer.domElement );
				controls.enableZoom = false;
				controls.minPolarAngle = Math.PI / 4;
				controls.maxPolarAngle = Math.PI / 1.5;

				//stats
				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				renderer.render( scene, camera );
				stats.update();

			}

		</script>

	</body>
</html>
