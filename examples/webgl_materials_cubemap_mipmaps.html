<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - cubemap mipmaps</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - cubemap customized mipmaps demo. Author <a href="https://github.com/AngusLang">Angus</a><br/>
			Top: webgl generated mipmaps<br/>
			Bottom: customized mimaps<br/>
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			var container, stats;

			var camera, scene, renderer;

			init();
			animate();

			// load custmized cube texture
			async function loadCubeTextureWithMipmaps() {

				var path = 'textures/cube/angus/';
				var format = '.jpg';
				var mipmaps = [];

				async function loadCubeTexture( urls ) {
					return new Promise( function( resolve, reject) {
						new THREE.CubeTextureLoader().load( urls, function( cubeTexture ) {
							resolve( cubeTexture );
						} );
					} );
				}

				//load mipmaps
				var pendings = [];
				for ( var level = 0; level < 9; ++ level ) {

					var urls = [];
					for ( var face = 0; face < 6; ++ face ) {
						urls.push( path + 'cube_m0' + level + '_c0' + face + format );
					}

					pendings.push( loadCubeTexture( urls ).then( function( cubeTexture ) {

						mipmaps.push( cubeTexture );

					} ) );

				}

				await Promise.all( pendings );

				var customizedCubeTexture = mipmaps.shift();
				customizedCubeTexture.mipmaps = mipmaps;
				customizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;
				customizedCubeTexture.magFilter = THREE.LinearFilter;
				customizedCubeTexture.generateMipmaps = false;
				customizedCubeTexture.needsUpdate = true;
	
				return customizedCubeTexture;

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( -1750, 0, 500 );

				//load cubemap

				scene = new THREE.Scene();

				//lights
				var ambient = new THREE.AmbientLight( 0xffffff, 1.0 );
				scene.add( ambient );

				var pendings = [];
				var reflectCubeTexture = loadCubeTextureWithMipmaps().then( function( reflectCubeTexture ) {

					//rewrite mipmaps
					var originalCubeTexture = reflectCubeTexture.clone();
					originalCubeTexture.generateMipmaps = true;
					originalCubeTexture.needsUpdate = true;

					//models
					var sphere = new THREE.SphereBufferGeometry( 100, 128, 128 );

					var material = new THREE.MeshPhongMaterial( { color: 0xffffff, envMap: reflectCubeTexture } );

					var offset = 250;
					var originX = -1150;
					for ( var i = 0; i < 10; ++ i ) {

						//customize mipmaps sphere
						var cm = material.clone();
						cm.envMap = originalCubeTexture;

						var c = new THREE.Mesh( sphere, cm );
						c.position.set( originX + i * offset, 150, 0 );
						scene.add( c );

						//webgl mipmaps sphere
						var om = material.clone();
						var o = new THREE.Mesh( sphere, om );
						o.position.set( originX + i * offset, -150, 0 );
						scene.add( o );
					}

				} );

				//renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//controls
				var controls = new OrbitControls( camera, renderer.domElement );
				controls.minPolarAngle = Math.PI / 4;
				controls.maxPolarAngle = Math.PI / 1.5;

				//stats
				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				renderer.render( scene, camera );
				stats.update();

			}

		</script>

	</body>
</html>
