<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - instancing test</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #ffffff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
        }

        a {
            color: #ffffff;
        }

        #oldie a {
            color: #da0;
        }
        #notSupported {
          width: 50%;
          margin: auto;
          border: 2px red solid;
          margin-top: 20px;
          padding: 10px;
        }
    </style>
</head>
<body>

    <div id="container"></div>
    <div id="info">
        <a href="http://threejs.org" target="_blank">three.js</a> - instancing demo
        <div id="notSupported" style="display:none">Sorry your graphics card + browser does not support hardware instancing</div>
    </div>

    <script src="../build/three.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">

        precision highp float;

        uniform float sineTime;

        uniform mat4 modelViewMatrix; // optional
        uniform mat4 projectionMatrix; // optional

        attribute vec3 position;
        attribute vec3 offset;
        attribute vec4 color;
        attribute vec4 rotationStart;
        attribute vec4 rotationEnd;

        varying vec3 vPosition;
        varying vec4 vColor;

        void main()	{

        vPosition = offset * max(abs(sineTime * 2.0 + 1.0), 0.5) + position;
        vec4 rotation = normalize(mix(rotationStart, rotationEnd, sineTime));
        vec3 vcV = cross(rotation.xyz, vPosition);
        vPosition = vcV * (2.0 * rotation.w) + (cross(rotation.xyz, vcV) * 2.0 + vPosition);

        vColor = color;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

        }

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

        precision highp float;

        uniform float time;

        varying vec3 vPosition;
        varying vec4 vColor;

        void main()	{

        vec4 color = vec4( vColor );
        color.r += sin( vPosition.x * 10.0 + time ) * 0.5;

        gl_FragColor = color;

        }

    </script>

    <script>

        if ( !Detector.webgl ) Detector.addGetWebGLMessage();

        var container, stats;

        var camera, scene, renderer;

        init();
        animate();

        function init() {

            container = document.getElementById( 'container' );

            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10 );
            camera.position.z = 2;

            scene = new THREE.Scene();

            // geometry

            var triangles = 1;
            var instances = 65000;

            var geometry = new THREE.InstancedBufferGeometry();

            var vertices = new THREE.BufferAttribute( new Float32Array( triangles * 3 * 3 ), 3 );

            vertices.setXYZ( 0, 0.025, -0.025, 0 );
            vertices.setXYZ( 1, -0.025, 0.025, 0 );
            vertices.setXYZ( 2, 0, 0, 0.025 );

            geometry.addAttribute( 'position', vertices );

            var offsets = new THREE.InstancedBufferAttribute( new Float32Array( instances * 3 ), 3, 1, false );

            for ( var i = 0, ul = offsets.length / 3; i < ul; i++ ) {

                offsets.setXYZ( i, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );

            }

            geometry.addAttribute( 'offset', offsets );

            var colors = new THREE.InstancedBufferAttribute( new Float32Array( instances * 4 ), 4, 1, false );

            for ( var i = 0, ul = colors.length / 4; i < ul; i++ ) {

                colors.setXYZW( i, Math.random(), Math.random(), Math.random(), Math.random() );

            }

            geometry.addAttribute( 'color', colors );

            var vector = new THREE.Vector4();

            var rotationsStart = new THREE.InstancedBufferAttribute( new Float32Array( instances * 4 ), 4, 1, false );

            for ( var i = 0, ul = rotationsStart.length / 4; i < ul; i++ ) {

                vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
                vector.normalize();

                rotationsStart.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

            }

            geometry.addAttribute( 'rotationStart', rotationsStart );

            var rotationsEnd = new THREE.InstancedBufferAttribute( new Float32Array( instances * 4 ), 4, 1, false );

            for ( var i = 0, ul = rotationsEnd.length / 4; i < ul; i++ ) {

                vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
                vector.normalize();

                rotationsEnd.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

            }

            geometry.addAttribute( 'rotationEnd', rotationsEnd );

            // material

            var material = new THREE.RawShaderMaterial( {

                uniforms: {
                    time: { type: "f", value: 1.0 },
                    sineTime: { type: "f", value: 1.0 }
                },
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                side: THREE.DoubleSide,
                transparent: true,
                attributes: { 'position': 0, 'offset': 1, 'color': 2, 'rotationStart': 3, 'rotationEnd': 4 }

            } );

            var mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );

            renderer = new THREE.WebGLRenderer();

            if ( !renderer.supportsInstancedArrays ) {
                document.getElementById( "notSupported" ).style.display = "";
                return;
            }

            renderer.setClearColor( 0x101010 );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            container.appendChild( stats.domElement );

            window.addEventListener( 'resize', onWindowResize, false );

        }

        function onWindowResize( event ) {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        //

        function animate() {

            requestAnimationFrame( animate );

            render();
            stats.update();

        }

        var lastTime = 0;

        function render() {

            var time = performance.now();


            var object = scene.children[0];

            object.rotation.y = time * 0.0005;
            object.material.uniforms.time.value = time * 0.005;
            object.material.uniforms.sineTime.value = Math.sin( object.material.uniforms.time.value * 0.05 );

            renderer.render( scene, camera );

            lastTime = time;
        }

    </script>

</body>

</html>