<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			.info {
				position: absolute;
				background-color: black;
				opacity: 0.8;
				color: white;
				text-align: center;
				top: 0px;
				width: 100%;
			}

			.info a {
				color: #00ffff;
			}
		</style>
	</head>
	<body>
		<script src="../build/three.js"></script>
		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/HalftonePass.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/HalftoneShader.js"></script>
		<script src="js/shaders/DepthLimitedBlurShader.js"></script>
		<script src="js/shaders/UnpackDepthRGBAShader.js"></script>
		<script src="js/Detector.js"></script>
		<script src='js/libs/dat.gui.min.js'></script>

		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener noreferrer">three.js</a> - Halftone shader by @meatbags
		</div>

		<script>

		if (!Detector.webgl) {
			Detector.addGetWebGLMessage();
		}

		class Example {
			constructor() {
				this.wrapper = document.createElement('div');
				document.body.appendChild(this.wrapper);

			 	this.clock = new THREE.Clock();
			 	this.width = window.innerWidth;
			 	this.height = window.innerHeight;
			 	this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 1, 1000);
				this.camera.position.z = 20;
				this.rotationSpeed = Math.PI / 8;

				this.initScene();
				this.initRender();
				this.initGUI();
				this.loop();
			}

			initScene() {
				var geo = new THREE.BoxBufferGeometry(1, 1, 1);
				var mat = new THREE.MeshBasicMaterial({});
				this.group = new THREE.Group();

				for (var i=0, len=20; i<len; ++i) {
					var mesh = new THREE.Mesh(geo.clone(), mat.clone());
					mesh.position.x = Math.random() * 10 - 5;
					mesh.position.y = Math.random() * 10 - 5;
					mesh.position.z = Math.random() * 10 - 5;
					this.group.add(mesh);
				}

				this.scene = new THREE.Scene();
				this.scene.background = new THREE.Color(0x111111);
				this.scene.add(this.group);
			}

			initRender() {
				// 3js renderer
				this.renderer = new THREE.WebGLRenderer({antialias: true});
				this.renderer.setPixelRatio(window.devicePixelRatio);
				this.renderer.setSize(window.innerWidth, window.innerHeight);

				// effect composer
				this.composer = new THREE.EffectComposer(this.renderer);
			 	this.renderPass = new THREE.RenderPass(this.scene, this.camera);
				this.halftonePass = new THREE.HalftonePass(this.width, this.height);
				this.halftonePass.renderToScreen = true;
				this.composer.addPass(this.renderPass);
				this.composer.addPass(this.halftonePass);

				// add to doc
				this.wrapper.appendChild(this.renderer.domElement);
			}

			initGUI() {
				var guiTarget = this.halftonePass.uniforms;
				var controller = {
					radius: 5,
					rotateSampleGrid: 45,
					rotateC: 45,
					rotateM: 30,
					rotateY: 60,
					shape: 1
				};
				var onGUIChange = function() {
					guiTarget.radius.value = controller.radius;
					guiTarget.rSample.value = controller.rotateSampleGrid * (Math.PI / 180);
					guiTarget.rC.value = controller.rotateC * (Math.PI / 180);
					guiTarget.rM.value = controller.rotateM * (Math.PI / 180);
					guiTarget.rY.value = controller.rotateY * (Math.PI / 180);
					guiTarget.shape.value = controller.shape;
				};
				this.gui = new dat.GUI();
				this.gui.add(controller, 'shape', {'dot': 1, 'euclidean-dot': 2, 'ellipse': 3, 'line': 4}).onChange(onGUIChange);
				this.gui.add(controller, 'radius', 1, 50).onChange(onGUIChange);
				this.gui.add(controller, 'rotateSampleGrid', 0, 360).onChange(onGUIChange);
				this.gui.add(controller, 'rotateC', 0, 360).onChange(onGUIChange);
				this.gui.add(controller, 'rotateM', 0, 360).onChange(onGUIChange);
				this.gui.add(controller, 'rotateY', 0, 360).onChange(onGUIChange);

				// reset
				onGUIChange();
			}


			loop() {
				requestAnimationFrame(() => { this.loop(); });
				var delta = this.clock.getDelta();
				//this.group.rotation.y += delta * this.rotationSpeed;
				this.composer.render(delta);
			}
		}

		var example = new Example();

		</script>
	</body>
</html>
